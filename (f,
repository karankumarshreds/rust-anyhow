#[derive(Debug)]
struct ErrorA;

#[derive(Debug)]
struct ErrorB;

#[derive(Debug)]
enum AppError {
    ErrorA,
    ErrorB,
}

impl From<ErrorB> for ErrorA {
    fn from(_: ErrorB) -> Self {
        ErrorA
    }
}

impl From<ErrorA> for AppError {
    fn from(_: ErrorA) -> Self {
        AppError::ErrorA
    }
}

impl From<ErrorB> for AppError {
    fn from(_: ErrorB) -> Self {
        AppError::ErrorB
    }
}


impl std::error::Error for ErrorA {}
impl std::fmt::Display for ErrorA {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ErrorA occured")
    }
}

impl std::error::Error for ErrorB {}
impl std::fmt::Display for ErrorB {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ErrorB occured")
    }
}

fn return_a() -> Result<(), ErrorA> {
    Err(ErrorA)
}
fn return_b() -> Result<(), ErrorB> {
    Err(ErrorB)
}

fn return_a_a() -> Result<(), anyhow::Error> {
    Err(ErrorA)
}
fn return_b_b() -> Result<(), anyhow::Error> {
    Err(ErrorA)
}


fn main() -> Result<(), AppError> {
    // without anyhow
    let _ = return_b()?;
    let _ = return_a()?;
    Ok(())
}
